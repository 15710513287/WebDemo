jq为什么出现
	容易上手，强大的选择器，节约开发时间，丰富的UI，完善的事件机制，Ajax的封装。

alert输出换行  :\\n

js的数据类型有哪些
	string
	number  (typeof NaN === 'number')
	bool
	undefined
	null
	object
	symbol  (es6新增数据类型)

promise
	使用方法
		.then  
			$.ajax(...).then(成功函数/失败函数);
		
		链式then
			$.ajax(...).then(成功函数/失败函数).then(成功函数/失败函数);
			这里即使第一个then触发失败函数  第二个then也会执行
			
		自己生成Promise
			function pro(){
				return new Promise(function(resolve,reject){
					setTimeout(()=>{
						resolve()或reject();    //调用成功函数或者失败函数
					},3000)
				})
			}
			调用  pro().then(...);
			
	http://www.cnblogs.com/rubylouvre/p/3495286.html
	(还不是很理解，异步代码？)
	
ajax 
	let xhr = new XMLHTTPRequest();
	xhr.open('POST','/xxx');
	xhr.onreadystatechange = function(){
		if(xhr.readystate === 4 && xhr.status === 200){
			console.log(xhr.responseText);
		}
	}
	xhr.send('a=1&b=2');

闭包
	function foo(){
		var local = 1;
		function bar(){
			local++;
			return local;
		}
		return bar;
	}
	
	var func = foo(); 
	func();  每次执行则 local+1

this的指向
	1. fn() 里面的this就是window
	2. fn() 是strict mode(严格模式) this是undefined
	3. a.fn()  里面的this就是a 也就是this指向实例
	4. new fn() 里面的this就是新生成的实例
	5. ()=>console.log(this)  里面的this和外面的this等值
	
立即执行函数
	;(function(){
		
	})() 	
	主要用于制造一个函数作用域  避免污染全局变量
	最前面的分号是用于避免解析出错（防御性分号）
	es6中可以直接使用{}制造一个函数作用域

async/await 语法以及目的
	

跨域的解决方法和原理

继承

apply和cell方法的作用与差异